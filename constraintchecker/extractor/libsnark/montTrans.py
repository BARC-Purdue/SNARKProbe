import os
import re
import subprocess

import extractor.libsnark.constraintMatrix as cm

import extractor.libsnark.extractorConfig as config

from config import *

class MontTrans(object):
    def __init__(self, dst_cs, dst_aux, dst_pub):
        """MontTrans, str -> None"""
        self.varfile_cs = config.CONSTRAINT_LOG
        self.varfile_aux = config.PRIAUXVAR_LOG
        self.varfile_pub = config.PUBLICVAR_LOG
        self.outfile_pre_cs = config.CONSTRAINT_PRE
        self.outfile_cs = dst_cs
        self.outfile_aux = dst_aux
        self.outfile_pub = dst_pub

        self.tansprog = os.path.join(ABSPATH, "utils/mont_repr_translate/mont")

        self.mr1cslst = []
        self.r1cslst = []
        
        self.r1csmatrix_public_input = -1
        self.r1csmatrix_private_input = -1
        self.r1csmatrix_num_constraints = -1
        self.r1csmatrix_constraint = []

        self.mauxlst = []
        self.auxlst = []

        self.mpublst = []
        self.publst = []

        self.clear()

    def clear(self):
        """Remove files generated by this class
        
        MontTrans -> None"""
        cprint.info("Remove old GDB and LOG files for montgomery representation translate", 2)
        
        if (os.path.exists(self.outfile_cs)):
            os.remove(self.outfile_cs)

        if (os.path.exists(self.outfile_aux)):
            os.remove(self.outfile_aux)
        
        if (os.path.exists(self.outfile_pub)):
            os.remove(self.outfile_pub)
            
    def readlog(self):
        """Read r1cs list and public variables from GDB logging
        
        VarExtractor -> None"""
        self.mr1cslst.clear()
        self.mauxlst.clear()
        self.mpublst.clear()

        # Read constraint log file
        f = open(self.varfile_cs)
        contents = f.readlines()
        f.close()

        while ("\n" in contents):
            contents.remove("\n")

        for content in contents:
            self.mr1cslst.append(content.strip("\n"))
        
        # Read private variable log file
        f = open(self.varfile_aux)
        contents = f.readlines()
        f.close()

        while ("\n" in contents):
            contents.remove("\n")

        for content in contents:
            self.mauxlst.append(content.strip("\n"))

        # Read public variable log file
        f = open(self.varfile_pub)
        contents = f.readlines()
        f.close()

        while ("\n" in contents):
            contents.remove("\n")

        for content in contents:
            self.mpublst.append(content.strip("\n"))
    
    def translate(self, mont):
        """Convert the montgomery representation into integer format
        
        VarExtractor, str -> int"""
        m1, m2, m3, m4 = re.findall(r'[0-9]+', mont)

        exit = subprocess.run([self.tansprog, m1, m2, m3, m4], stdout = subprocess.PIPE)
        num = int(exit.stdout)

        return num

    def translateAll(self):
        """Convert the R1CS list with montgomery representation into R1CS list with integer format only
        
        VarExtractor -> None"""
        self.r1cslst.clear()
        self.auxlst.clear()
        self.publst.clear()
        
        # Translate constraint logs
        cprint.info("Convert montgomery representation in constraint variable", 3)
        
        for numstr in self.mr1cslst:
            count = len(re.findall(r'[0-9]+', numstr))
            if (count == 1):
                self.r1cslst.append(numstr)
            elif (count == 4):
                num = self.translate(numstr)
                self.r1cslst.append(str(num))
            else:
                cprint.error("Number are not in integer format nor montgomery representation")
                raise ValueError("Number are not in integer format nor montgomery representation")

        # Translate private variable log
        cprint.info("Convert montgomery representation in auxiliary variable(s) value", 3)
        
        for numstr in self.mauxlst:
            count = len(re.findall(r'[0-9]+', numstr))
            if (count == 1):
                self.auxlst.append(numstr)
            elif (count == 4):
                num = self.translate(numstr)
                self.auxlst.append(str(num))
            else:
                cprint.error("Number are not in integer format nor montgomery representation")
                raise ValueError("Number are not in integer format nor montgomery representation")

        # Translate public variable log
        cprint.info("Convert montgomery representation in public variable(s) value", 3)
        
        for numstr in self.mpublst:
            count = len(re.findall(r'[0-9]+', numstr))
            if (count == 1):
                self.publst.append(numstr)
            elif (count == 4):
                num = self.translate(numstr)
                self.publst.append(str(num))
            else:
                cprint.error("Number are not in integer format nor montgomery representation")
                raise ValueError("Number are not in integer format nor montgomery representation")

    def r1csMatrix(self):
        cprint.info("Convert constraint variable from list format in libsnark to matrix format", 3)
        
        f = open(self.outfile_pre_cs, "w")

        for i in range(len(self.r1cslst)):
            f.write(self.r1cslst[i])
            if (i != len(self.r1cslst) - 1):
                f.write("\n")

        f.close()
        
        cb = cm.ConstraintBuild(self.outfile_pre_cs)
        cb.buildConstraint()
        
        self.r1csmatrix_public_input = cb.public_input
        self.r1csmatrix_private_input = cb.private_input
        self.r1csmatrix_num_constraints = cb.num_constraints
        self.r1csmatrix_constraint = cb.constraint

    def writer1cslst(self):
        """Write the r1cs list in integer format
        
        VarExtractor -> None"""
        cprint.info("Write constraint matrix, auxiliary variable(s), and public variable(s)", 3)
        
        # Write constraint output file
        f = open(self.outfile_cs, "w")
        f.write(str(self.r1csmatrix_public_input) + "\n")
        f.write(str(self.r1csmatrix_private_input) + "\n")
        f.write(str(self.r1csmatrix_num_constraints) + "\n")
        f.write(str(self.r1csmatrix_constraint) + "\n")
        f.close()

        # Write private variable output file
        f = open(self.outfile_aux, "w")

        for i in range(len(self.auxlst)):
            f.write(self.auxlst[i])
            if (i != len(self.auxlst) - 1):
                f.write("\n")

        f.close()

        # Write public variable output file
        f = open(self.outfile_pub, "w")

        for i in range(len(self.publst)):
            f.write(self.publst[i])
            if (i != len(self.publst) - 1):
                f.write("\n")

        f.close()

## if __name__ == "__main__":
##     # test case
##     mt = MontTrans("FILE1", "FILE2")
##     mt.readlog()
##     mt.translateAll()
##     mt.writer1cslst()